// Assets/MayaImporter/Editor/MayaNodeTypeStubGenerator.cs
// Unity-only (no Maya/Autodesk API)
//
// Generates missing nodeType scripts to satisfy:
// - 100% condition: "Maya 2026 standard node types ALL exist as scripts"
// - 100 points: those scripts create Unity-side representation (opaque runtime)
//
// IMPORTANT:
// - This does NOT require Maya to run.
// - Requires the standard list file:
//   Assets/MayaImporter/Resources/Maya2026_StandardNodeTypes.txt

#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;
using MayaImporter.Core;

namespace MayaImporter.EditorTools
{
    public static class MayaNodeTypeStubGenerator
    {
        // Where generated stubs will be placed.
        // Keep it under Assets so it is included in the project & compiled.
        public const string OutputFolder = "Assets/MayaImporter/Generated/StandardNodeTypeStubs";

        // Namespace for generated classes.
        public const string OutputNamespace = "MayaImporter.Nodes.Generated";

        // Base class for generated stubs:
        // - Applies "opaque runtime" components automatically
        // - Keeps attributes/connections (lossless-ish)
        private const string BaseClassName = "MayaPhaseCOpaqueRuntimeNodeBase";

        [MenuItem("Tools/Maya Importer/Coverage/Generate Missing NodeType Stubs (Maya2026)...", priority = 220)]
        public static void Menu_GenerateMissingStubs()
        {
            try
            {
                GenerateMissingStubs(interactive: true);
            }
            catch (Exception ex)
            {
                Debug.LogException(ex);
                EditorUtility.DisplayDialog("MayaImporter", "Stub generation failed:\n" + ex.Message, "OK");
            }
        }

        /// <summary>
        /// Generates stubs for nodeTypes that are present in Maya2026_StandardNodeTypes.txt
        /// but missing from the current Unity scripts.
        /// </summary>
        public static void GenerateMissingStubs(bool interactive)
        {
            // 1) Load standard list
            if (!MayaStandardNodeTypes.TryGet(out var standard) || standard == null || standard.Count == 0)
            {
                EditorUtility.DisplayDialog(
                    "MayaImporter",
                    "Standard nodeType list not found.\n\nPut this file:\nAssets/MayaImporter/Resources/Maya2026_StandardNodeTypes.txt\n\n(one nodeType per line)",
                    "OK");
                return;
            }

            // 2) Build current registry snapshot
            var snap = MayaNodeTypeRegistryCache.GetOrBuild(forceRebuild: true);

            // 3) Determine missing
            var missing = standard
                .Where(nt => !snap.AllNodeTypes.Contains(nt))
                .OrderBy(nt => nt, StringComparer.Ordinal)
                .ToList();

            if (missing.Count == 0)
            {
                EditorUtility.DisplayDialog("MayaImporter", "No missing standard nodeTypes. âœ…", "OK");
                return;
            }

            // 4) Confirm (interactive)
            if (interactive)
            {
                if (!EditorUtility.DisplayDialog(
                        "MayaImporter",
                        $"Missing standard nodeTypes: {missing.Count}\n\nGenerate stubs into:\n{OutputFolder}\n\nEach stub derives from {BaseClassName}.",
                        "Generate",
                        "Cancel"))
                    return;
            }

            EnsureFolder(OutputFolder);

            int created = 0;
            int skipped = 0;

            for (int i = 0; i < missing.Count; i++)
            {
                var nodeType = missing[i];
                var className = ToSafeClassName(nodeType);

                // Ensure unique file/class name in output folder
                var fileName = className + ".cs";
                var assetPath = Path.Combine(OutputFolder, fileName).Replace("\\", "/");

                if (File.Exists(assetPath))
                {
                    skipped++;
                    continue;
                }

                var code = BuildStubCode(nodeType, className);
                File.WriteAllText(assetPath, code, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
                created++;
            }

            AssetDatabase.Refresh();

            var msg = $"Generated stubs: {created}\nSkipped (already existed): {skipped}\n\nFolder:\n{OutputFolder}";
            if (interactive)
                EditorUtility.DisplayDialog("MayaImporter", msg, "OK");
            else
                Debug.Log("[MayaImporter] " + msg);
        }

        private static string BuildStubCode(string nodeType, string className)
        {
            var sb = new StringBuilder(1024);

            sb.AppendLine("// AUTO-GENERATED by MayaNodeTypeStubGenerator");
            sb.AppendLine("//");
            sb.AppendLine("// NodeType: " + nodeType);
            sb.AppendLine("// Behavior:");
            sb.AppendLine("// - Creates an \"opaque\" Unity-side representation");
            sb.AppendLine("// - Preserves raw attributes + connections");
            sb.AppendLine("// - Does NOT attempt semantic reconstruction yet (add later if needed)");
            sb.AppendLine("//");
            sb.AppendLine("// Safe to ship: Unity-only, no Autodesk/Maya API.");
            sb.AppendLine();
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using MayaImporter;");
            sb.AppendLine("using MayaImporter.Core;");
            sb.AppendLine();
            sb.AppendLine("namespace " + OutputNamespace);
            sb.AppendLine("{");
            sb.AppendLine($"    [MayaNodeType(\"{EscapeForAttribute(nodeType)}\")]");
            sb.AppendLine("    [DisallowMultipleComponent]");
            sb.AppendLine($"    public sealed class {className} : {BaseClassName}");
            sb.AppendLine("    {");
            sb.AppendLine("        // Intentionally empty.");
            sb.AppendLine("        // The base class attaches Opaque runtime/preview components in ApplyToUnity().");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void EnsureFolder(string assetFolder)
        {
            assetFolder = (assetFolder ?? "").Replace("\\", "/").TrimEnd('/');
            if (string.IsNullOrEmpty(assetFolder))
                throw new ArgumentException("Output folder is empty.");

            if (AssetDatabase.IsValidFolder(assetFolder))
                return;

            // Create nested folders from Assets/
            var parts = assetFolder.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length == 0 || parts[0] != "Assets")
                throw new ArgumentException("Output folder must be under Assets/");

            var current = "Assets";
            for (int i = 1; i < parts.Length; i++)
            {
                var next = current + "/" + parts[i];
                if (!AssetDatabase.IsValidFolder(next))
                {
                    AssetDatabase.CreateFolder(current, parts[i]);
                }
                current = next;
            }
        }

        private static string EscapeForAttribute(string s)
        {
            if (string.IsNullOrEmpty(s)) return "";
            return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
        }

        /// <summary>
        /// Converts a Maya nodeType string into a stable C# class name.
        /// Example: \"blendShape\" -> \"BlendShapeNode\".
        /// </summary>
        public static string ToSafeClassName(string nodeType)
        {
            var raw = (nodeType ?? "").Trim();
            if (raw.Length == 0) return "UnknownNodeTypeNode";

            // Split on non-alnum and camel-case boundaries
            var tokens = new List<string>();
            var sb = new StringBuilder();

            void Flush()
            {
                if (sb.Length > 0)
                {
                    tokens.Add(sb.ToString());
                    sb.Length = 0;
                }
            }

            for (int i = 0; i < raw.Length; i++)
            {
                char c = raw[i];

                if (char.IsLetterOrDigit(c))
                {
                    // camelCase boundary: ...aB...
                    if (sb.Length > 0 && char.IsLower(sb[sb.Length - 1]) && char.IsUpper(c))
                        Flush();

                    sb.Append(c);
                }
                else
                {
                    Flush();
                }
            }
            Flush();

            if (tokens.Count == 0)
                tokens.Add("NodeType");

            var name = string.Concat(tokens.Select(ToPascal));
            if (name.Length == 0) name = "NodeType";

            // C# identifier: cannot start with digit
            if (char.IsDigit(name[0]))
                name = "Node" + name;

            // Avoid keywords (minimal)
            if (name == "Class" || name == "Namespace" || name == "Object")
                name = "Maya" + name;

            if (!name.EndsWith("Node", StringComparison.Ordinal))
                name += "Node";

            return name;
        }

        private static string ToPascal(string s)
        {
            if (string.IsNullOrEmpty(s)) return "";
            if (s.Length == 1) return char.ToUpperInvariant(s[0]).ToString();

            // Preserve existing uppercase acronyms reasonably
            return char.ToUpperInvariant(s[0]) + s.Substring(1);
        }
    }
}
#endif
